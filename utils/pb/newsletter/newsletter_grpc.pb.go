// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: utils/pb/newsletter/newsletter.proto

package __

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	NewsLetter_AddSubscription_FullMethodName                  = "/newsletter.NewsLetter/AddSubscription"
	NewsLetter_CancelSubscription_FullMethodName               = "/newsletter.NewsLetter/CancelSubscription"
	NewsLetter_CreateNewsletter_FullMethodName                 = "/newsletter.NewsLetter/CreateNewsletter"
	NewsLetter_GetNewsLetter_FullMethodName                    = "/newsletter.NewsLetter/GetNewsLetter"
	NewsLetter_ListNewsLetters_FullMethodName                  = "/newsletter.NewsLetter/ListNewsLetters"
	NewsLetter_GetSubscriptionAndPaymentDetails_FullMethodName = "/newsletter.NewsLetter/GetSubscriptionAndPaymentDetails"
	NewsLetter_UpdateSubscriptionAndPayment_FullMethodName     = "/newsletter.NewsLetter/UpdateSubscriptionAndPayment"
	NewsLetter_GetSubscribers_FullMethodName                   = "/newsletter.NewsLetter/GetSubscribers"
	NewsLetter_GetSubscription_FullMethodName                  = "/newsletter.NewsLetter/GetSubscription"
)

// NewsLetterClient is the client API for NewsLetter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NewsLetterClient interface {
	AddSubscription(ctx context.Context, in *SubscriptionReq, opts ...grpc.CallOption) (*SPR, error)
	CancelSubscription(ctx context.Context, in *Subid, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CreateNewsletter(ctx context.Context, in *NewsLetterReq, opts ...grpc.CallOption) (*NewsLetterRes, error)
	GetNewsLetter(ctx context.Context, in *NLid, opts ...grpc.CallOption) (*NewsLetterRes, error)
	ListNewsLetters(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListNewsLetterRes, error)
	GetSubscriptionAndPaymentDetails(ctx context.Context, in *Subid, opts ...grpc.CallOption) (*SPR, error)
	UpdateSubscriptionAndPayment(ctx context.Context, in *UpdateSubscriptionAndPaymentReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetSubscribers(ctx context.Context, in *GetSubscribersReq, opts ...grpc.CallOption) (*GetSubscribersRes, error)
	GetSubscription(ctx context.Context, in *SubscriptionReq, opts ...grpc.CallOption) (*ArrSPR, error)
}

type newsLetterClient struct {
	cc grpc.ClientConnInterface
}

func NewNewsLetterClient(cc grpc.ClientConnInterface) NewsLetterClient {
	return &newsLetterClient{cc}
}

func (c *newsLetterClient) AddSubscription(ctx context.Context, in *SubscriptionReq, opts ...grpc.CallOption) (*SPR, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SPR)
	err := c.cc.Invoke(ctx, NewsLetter_AddSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newsLetterClient) CancelSubscription(ctx context.Context, in *Subid, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NewsLetter_CancelSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newsLetterClient) CreateNewsletter(ctx context.Context, in *NewsLetterReq, opts ...grpc.CallOption) (*NewsLetterRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NewsLetterRes)
	err := c.cc.Invoke(ctx, NewsLetter_CreateNewsletter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newsLetterClient) GetNewsLetter(ctx context.Context, in *NLid, opts ...grpc.CallOption) (*NewsLetterRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NewsLetterRes)
	err := c.cc.Invoke(ctx, NewsLetter_GetNewsLetter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newsLetterClient) ListNewsLetters(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListNewsLetterRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNewsLetterRes)
	err := c.cc.Invoke(ctx, NewsLetter_ListNewsLetters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newsLetterClient) GetSubscriptionAndPaymentDetails(ctx context.Context, in *Subid, opts ...grpc.CallOption) (*SPR, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SPR)
	err := c.cc.Invoke(ctx, NewsLetter_GetSubscriptionAndPaymentDetails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newsLetterClient) UpdateSubscriptionAndPayment(ctx context.Context, in *UpdateSubscriptionAndPaymentReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NewsLetter_UpdateSubscriptionAndPayment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newsLetterClient) GetSubscribers(ctx context.Context, in *GetSubscribersReq, opts ...grpc.CallOption) (*GetSubscribersRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSubscribersRes)
	err := c.cc.Invoke(ctx, NewsLetter_GetSubscribers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newsLetterClient) GetSubscription(ctx context.Context, in *SubscriptionReq, opts ...grpc.CallOption) (*ArrSPR, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArrSPR)
	err := c.cc.Invoke(ctx, NewsLetter_GetSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NewsLetterServer is the server API for NewsLetter service.
// All implementations must embed UnimplementedNewsLetterServer
// for forward compatibility.
type NewsLetterServer interface {
	AddSubscription(context.Context, *SubscriptionReq) (*SPR, error)
	CancelSubscription(context.Context, *Subid) (*emptypb.Empty, error)
	CreateNewsletter(context.Context, *NewsLetterReq) (*NewsLetterRes, error)
	GetNewsLetter(context.Context, *NLid) (*NewsLetterRes, error)
	ListNewsLetters(context.Context, *emptypb.Empty) (*ListNewsLetterRes, error)
	GetSubscriptionAndPaymentDetails(context.Context, *Subid) (*SPR, error)
	UpdateSubscriptionAndPayment(context.Context, *UpdateSubscriptionAndPaymentReq) (*emptypb.Empty, error)
	GetSubscribers(context.Context, *GetSubscribersReq) (*GetSubscribersRes, error)
	GetSubscription(context.Context, *SubscriptionReq) (*ArrSPR, error)
	mustEmbedUnimplementedNewsLetterServer()
}

// UnimplementedNewsLetterServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNewsLetterServer struct{}

func (UnimplementedNewsLetterServer) AddSubscription(context.Context, *SubscriptionReq) (*SPR, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSubscription not implemented")
}
func (UnimplementedNewsLetterServer) CancelSubscription(context.Context, *Subid) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelSubscription not implemented")
}
func (UnimplementedNewsLetterServer) CreateNewsletter(context.Context, *NewsLetterReq) (*NewsLetterRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNewsletter not implemented")
}
func (UnimplementedNewsLetterServer) GetNewsLetter(context.Context, *NLid) (*NewsLetterRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNewsLetter not implemented")
}
func (UnimplementedNewsLetterServer) ListNewsLetters(context.Context, *emptypb.Empty) (*ListNewsLetterRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNewsLetters not implemented")
}
func (UnimplementedNewsLetterServer) GetSubscriptionAndPaymentDetails(context.Context, *Subid) (*SPR, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubscriptionAndPaymentDetails not implemented")
}
func (UnimplementedNewsLetterServer) UpdateSubscriptionAndPayment(context.Context, *UpdateSubscriptionAndPaymentReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSubscriptionAndPayment not implemented")
}
func (UnimplementedNewsLetterServer) GetSubscribers(context.Context, *GetSubscribersReq) (*GetSubscribersRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubscribers not implemented")
}
func (UnimplementedNewsLetterServer) GetSubscription(context.Context, *SubscriptionReq) (*ArrSPR, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubscription not implemented")
}
func (UnimplementedNewsLetterServer) mustEmbedUnimplementedNewsLetterServer() {}
func (UnimplementedNewsLetterServer) testEmbeddedByValue()                    {}

// UnsafeNewsLetterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NewsLetterServer will
// result in compilation errors.
type UnsafeNewsLetterServer interface {
	mustEmbedUnimplementedNewsLetterServer()
}

func RegisterNewsLetterServer(s grpc.ServiceRegistrar, srv NewsLetterServer) {
	// If the following call pancis, it indicates UnimplementedNewsLetterServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NewsLetter_ServiceDesc, srv)
}

func _NewsLetter_AddSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscriptionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewsLetterServer).AddSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NewsLetter_AddSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewsLetterServer).AddSubscription(ctx, req.(*SubscriptionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NewsLetter_CancelSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Subid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewsLetterServer).CancelSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NewsLetter_CancelSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewsLetterServer).CancelSubscription(ctx, req.(*Subid))
	}
	return interceptor(ctx, in, info, handler)
}

func _NewsLetter_CreateNewsletter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewsLetterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewsLetterServer).CreateNewsletter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NewsLetter_CreateNewsletter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewsLetterServer).CreateNewsletter(ctx, req.(*NewsLetterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NewsLetter_GetNewsLetter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NLid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewsLetterServer).GetNewsLetter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NewsLetter_GetNewsLetter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewsLetterServer).GetNewsLetter(ctx, req.(*NLid))
	}
	return interceptor(ctx, in, info, handler)
}

func _NewsLetter_ListNewsLetters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewsLetterServer).ListNewsLetters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NewsLetter_ListNewsLetters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewsLetterServer).ListNewsLetters(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _NewsLetter_GetSubscriptionAndPaymentDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Subid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewsLetterServer).GetSubscriptionAndPaymentDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NewsLetter_GetSubscriptionAndPaymentDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewsLetterServer).GetSubscriptionAndPaymentDetails(ctx, req.(*Subid))
	}
	return interceptor(ctx, in, info, handler)
}

func _NewsLetter_UpdateSubscriptionAndPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSubscriptionAndPaymentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewsLetterServer).UpdateSubscriptionAndPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NewsLetter_UpdateSubscriptionAndPayment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewsLetterServer).UpdateSubscriptionAndPayment(ctx, req.(*UpdateSubscriptionAndPaymentReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NewsLetter_GetSubscribers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubscribersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewsLetterServer).GetSubscribers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NewsLetter_GetSubscribers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewsLetterServer).GetSubscribers(ctx, req.(*GetSubscribersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NewsLetter_GetSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscriptionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewsLetterServer).GetSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NewsLetter_GetSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewsLetterServer).GetSubscription(ctx, req.(*SubscriptionReq))
	}
	return interceptor(ctx, in, info, handler)
}

// NewsLetter_ServiceDesc is the grpc.ServiceDesc for NewsLetter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NewsLetter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "newsletter.NewsLetter",
	HandlerType: (*NewsLetterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddSubscription",
			Handler:    _NewsLetter_AddSubscription_Handler,
		},
		{
			MethodName: "CancelSubscription",
			Handler:    _NewsLetter_CancelSubscription_Handler,
		},
		{
			MethodName: "CreateNewsletter",
			Handler:    _NewsLetter_CreateNewsletter_Handler,
		},
		{
			MethodName: "GetNewsLetter",
			Handler:    _NewsLetter_GetNewsLetter_Handler,
		},
		{
			MethodName: "ListNewsLetters",
			Handler:    _NewsLetter_ListNewsLetters_Handler,
		},
		{
			MethodName: "GetSubscriptionAndPaymentDetails",
			Handler:    _NewsLetter_GetSubscriptionAndPaymentDetails_Handler,
		},
		{
			MethodName: "UpdateSubscriptionAndPayment",
			Handler:    _NewsLetter_UpdateSubscriptionAndPayment_Handler,
		},
		{
			MethodName: "GetSubscribers",
			Handler:    _NewsLetter_GetSubscribers_Handler,
		},
		{
			MethodName: "GetSubscription",
			Handler:    _NewsLetter_GetSubscription_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "utils/pb/newsletter/newsletter.proto",
}
